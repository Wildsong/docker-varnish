version: "3.9"

networks:
  proxy:
    name: ${NETWORK_NAME}
    external: true

volumes:
  certs:
    name: letsencrypt_certs
    external: true
  backup:
    name: letsencrypt_backups

services:

# Varnish and hitch will communicate over port 8443
# but since they share the same internal network there is no need to expose anything

  # I listen for everything on port 443, using Let's Encrypt certificates
  # and then just send everything over the PROXY connection to vanish on port 8443
  hitch:
    container_name: hitch
    image: cc/hitch
    build:
      dockerfile: Dockerfile.hitch
      context: .
    environment:
      TZ: 'America/Los_Angeles'
    ports:
      - "443:443"
    volumes:
      - ./${HITCH_FILE}:/etc/hitch/hitch.conf:ro
      - certs:/certs:rw
    depends_on:
      - varnish
    networks:
      - proxy
    restart: unless-stopped

  # I need to have port 80 visible so that I can redirect traffic to TLS.
  # Everything else comes in from hitch.
  varnish:
    container_name: varnish
    image: varnish:stable
    environment:
      TZ: 'America/Los_Angeles'
    ports:
      - "80:80" # Let's Encrypt needs this open
    volumes:
      - ./etc_varnish:/etc/varnish:ro
    tmpfs: "/var/lib/varnish/varnishd:rw,exec"
    networks:
      proxy:
        aliases:
          - varnish # hitch.conf needs this
    restart: unless-stopped

  # This serves http content for certbot, running on port 8000.
  # Certbot has to be able to write to its docs folder, but the http server does not.
  certbot_challenge:
    container_name: certbot_challenge
    image: cc/challenge
    build: 
      dockerfile: Dockerfile.challenge
      context: .
    ports:
      - "8000:8000" # Only needed for curl tests
    volumes:
      - ./acme-challenge:/www/.well-known/acme-challenge:ro
    networks:
      proxy:
        aliases:
          - challenger

  ####################################################################################
  # This service does not start automatically, it is run either as a separate command
  # or from crontab to renew certificates.

  certbot:
    image: cc/certbot
    volumes:
      - certs:/etc/letsencrypt:rw
      - backup:/var/lib/letsencrypt:rw
      # certbot writes a file here, then let's encrypt queries it via certbot-challenge
      - ${PWD}/acme-challenge:/www/.well-known/acme-challenge:rw
    profiles: 
      - "certbot" # Don't start automatically

      # Read options here https://eff-certbot.readthedocs.io/en/stable/using.html#configuration-file
    command:
      - "certonly" # Obtain certificate but don't try to install it.
      # options
      - "--dry-run" # Uncomment this for testing.
#      - "--quiet"
      - "-m ${EMAIL}"
      - "--noninteractive"
      - "--agree-tos"
      - "--webroot"
      - "--webroot-path=/www"
      - "--domains=${DOMAINS}"
      - "--deploy-hook=/etc/letsencrypt/bundle.sh"
      - "--disable-hook-validation"
      - "--max-log-backups=0"
      - "--allow-subset-of-names"
    restart: never

  cloudflare:
    image: cc/cloudflare
    build:
      dockerfile: Dockerfile.cloudflare
      context: .
    volumes:
      - certs:/etc/letsencrypt:rw
      - backup:/var/lib/letsencrypt:rw
    profiles: 
      - "cloudflare" # Don't start automatically

      # Read options here https://eff-certbot.readthedocs.io/en/stable/using.html#configuration-file
    command:
      - "certonly" # Obtain certificate but don't try to install it.
      # options
      #- "--dry-run" # Uncomment this for testing. It will throw errors with cloudflare
      - "--quiet"
      - "--noninteractive"
      - "-m ${EMAIL}"
      - "--agree-tos"
      - "--dns-cloudflare"
      - "--dns-cloudflare-credentials"
      - "/usr/local/lib/cloudflare.ini"
      - "--domains=${DOMAINS}"
      - "--deploy-hook=/etc/letsencrypt/bundle.sh"
      - "--disable-hook-validation"
      - "--max-log-backups=0"
      - "--allow-subset-of-names"
    restart: never
