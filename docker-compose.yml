version: "3.9"

networks:
  proxy:
    name: ${NETWORK_NAME}
    external: true

volumes:
  certs:
    name: letsencrypt_certs
    external: true
  backup:
    name: letsencrypt_backups

  # Connections to servers for the photo web server (www).
  bridges:
    name: cifs_bridges
    external: true
  waterway:
    name: cifs_waterway
    external: true

services:

# Varnish and hitch will communicate over port 8443
# but since they share the same internal network there is no need to expose anything

  # I listen for everything on port 443, using Let's Encrypt certificates
  # and then just send everything over the PROXY connection to vanish on port 8443
  hitch:
    container_name: hitch
    image: cc/hitch
    build:
      dockerfile: Dockerfile.hitch
      context: .
    environment:
      TZ: 'America/Los_Angeles'
    ports:
      - "443:443"
    volumes:
      - certs:/certs:ro
    depends_on:
      - varnish
    networks:
      - proxy
    restart: unless-stopped

  # I need to have port 80 visible so that I can redirect traffic to TLS.
  # Everything else comes in from hitch.
  varnish:
    container_name: varnish
    image: varnish:stable
    environment:
      TZ: 'America/Los_Angeles'
    ports:
      - "80:80" # Let's Encrypt needs this open
    volumes:
      - ./etc_varnish:/etc/varnish:ro
    tmpfs: "/var/lib/varnish/varnishd:rw,exec"
    networks:
      proxy:
        aliases:
          - varnish # hitch.conf needs this
    depends_on:
      - certbot_challenge
      - www
    restart: unless-stopped

  # This serves http content for certbot, running on port 8000.
  # Certbot has to be able to write to its docs folder, but the http server does not.
  certbot_challenge:
    container_name: certbot_challenge
    image: cc/challenge
    build: 
      dockerfile: Dockerfile.www
      context: .
    ports:
      - "8000:8000" # Only needed for curl tests
    volumes:
      - ./acme-challenge:/www/.well-known/acme-challenge:ro
    networks:
      proxy:
        aliases:
          - challenger

  # This web server hosts both the main landing page for the site
  # and the photo services
  www:
    container_name: www
    image: nginx:latest
    volumes:
      - ./webserver.conf:/etc/nginx/conf.d/default.conf
      - ./nginx_image_filter.conf:/etc/nginx/nginx.conf
      - ./www_content:/srv/www:ro
      - bridges:/srv/photos/bridges:ro
      - waterway:/srv/photos/waterway:ro
    networks:
      proxy:
        aliases:
          - www
    restart: unless-stopped

  ####################################################################################
  # This service does not start automatically, it is run either as a separate command
  # or from crontab to renew certificates.

  certbot:
    image: cc/certbot
    build:
      dockerfile: Dockerfile.certbot
      context: .
    volumes:
      - certs:/etc/letsencrypt:rw
      - backup:/var/lib/letsencrypt:rw
      # certbot writes a file here, then let's encrypt queries it via certbot-challenge
      - ${PWD}/acme-challenge:/www/.well-known/acme-challenge:rw
    profiles: 
      - "certbot" # Don't start automatically

      # Read options here https://eff-certbot.readthedocs.io/en/stable/using.html#configuration-file
    command:
      - "certonly" # Obtain certificate but don't try to install it.
      #- "enhance"
      #- "certificates" # Just show information about existing certificates
      # options
      - "--dry-run" # Uncomment this for testing.
 #     - "--test-cert" # Obtain a test certificate from a staging server
      - "-m ${EMAIL}"
      - "--noninteractive"
      - "--agree-tos"
      - "--webroot"
      - "--webroot-path=/www"
      - "--domains=${DOMAINS}"
      - '--deploy-hook=certbot_deploy.sh'
      - "--max-log-backups=0"
    restart: never
